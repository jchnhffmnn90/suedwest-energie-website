#!/usr/bin/env python3
"""
Penetration Testing Script for S√ºdwest-Energie Website

This script performs security testing on the S√ºdwest-Energie website,
identifying potential vulnerabilities and security issues.
"""

import requests
import json
import time
from datetime import datetime
from urllib.parse import urljoin
import re
import argparse
import sys
from typing import Dict, List, Tuple, Optional
import urllib3

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class SudwestEnergiePentester:
    def __init__(self, base_url: str = "http://localhost:3000", timeout: int = 10):
        """
        Initialize the pentester with the target URL
        
        Args:
            base_url: Base URL of the website to test
            timeout: Request timeout in seconds
        """
        self.base_url = base_url
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        })
        
        # Store test results
        self.test_results = {
            "start_time": datetime.now().isoformat(),
            "target": base_url,
            "test_results": [],
            "summary": {
                "total_tests": 0,
                "passed_tests": 0,
                "failed_tests": 0,
                "critical_vulnerabilities": 0,
                "high_vulnerabilities": 0,
                "medium_vulnerabilities": 0,
                "low_vulnerabilities": 0,
                "vulnerabilities_found": []
            }
        }

    def add_test_result(self, test_name: str, passed: bool, severity: str = "low", details: str = "", 
                       vulnerability_type: str = ""):
        """
        Add a test result to the results
        
        Args:
            test_name: Name of the test
            passed: Whether the test passed (no vulnerability found)
            severity: Severity level (critical, high, medium, low)
            details: Details about the test result
            vulnerability_type: Type of vulnerability if found
        """
        result = {
            "name": test_name,
            "passed": passed,
            "severity": severity,
            "details": details,
            "vulnerability_type": vulnerability_type,
            "timestamp": datetime.now().isoformat()
        }
        self.test_results["test_results"].append(result)
        self.test_results["summary"]["total_tests"] += 1

        if passed:
            self.test_results["summary"]["passed_tests"] += 1
            print(f"‚úÖ {test_name}")
        else:
            self.test_results["summary"]["failed_tests"] += 1
            # Determine vulnerability level based on severity
            if severity == "critical":
                self.test_results["summary"]["critical_vulnerabilities"] += 1
            elif severity == "high":
                self.test_results["summary"]["high_vulnerabilities"] += 1
            elif severity == "medium":
                self.test_results["summary"]["medium_vulnerabilities"] += 1
            else:
                self.test_results["summary"]["low_vulnerabilities"] += 1
            
            # Add to vulnerabilities found list
            if vulnerability_type:
                self.test_results["summary"]["vulnerabilities_found"].append({
                    "type": vulnerability_type,
                    "severity": severity,
                    "test": test_name,
                    "details": details
                })
            
            print(f"‚ùå {test_name}")
            if details:
                print(f"   Details: {details}")

    def check_security_headers(self):
        """Check for security headers"""
        print("\nüîç Testing Security Headers...")
        
        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            
            # Expected security headers
            expected_headers = [
                'X-Frame-Options',
                'X-XSS-Protection', 
                'X-Content-Type-Options',
                'Content-Security-Policy',
                'Strict-Transport-Security',
                'Referrer-Policy'
            ]
            
            found_headers = []
            missing_headers = []
            
            for header in expected_headers:
                if header in response.headers:
                    found_headers.append(header)
                else:
                    missing_headers.append(header)
            
            if missing_headers:
                details = f"Missing security headers: {', '.join(missing_headers)}"
                self.add_test_result("Security Headers Analysis", False, "medium", details, "Missing Security Headers")
            else:
                details = f"All expected headers present: {', '.join(found_headers)}"
                self.add_test_result("Security Headers Analysis", True, "low", details)
                
        except Exception as e:
            self.add_test_result("Security Headers Analysis", False, "medium", str(e), "HTTP Error")

    def test_xss_vulnerabilities(self):
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        print("\nüîç Testing for XSS Vulnerabilities...")
        
        # Common XSS payloads to test
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<h1>XSS</h1>",
            "'; alert('XSS'); '",
            "<iframe src=\"javascript:alert('XSS')\">",
        ]
        
        # Test contact form fields
        contact_form_fields = ["name", "email", "company", "message"]
        
        for field in contact_form_fields:
            for payload in xss_payloads:
                # Create a test form submission with XSS payload
                test_data = {
                    "name": "Test User",
                    "email": "test@example.com",
                    "phone": "+49 123 456789",
                    "company": "Test Company",
                    "message": "Test message"
                }
                
                # Inject the payload into the current field
                test_data[field] = payload
                
                try:
                    # Submit form and check response
                    response = self.session.post(self.base_url, data=test_data, timeout=self.timeout)
                    
                    # Check if the payload appears in the response (indicating potential XSS)
                    # This is a basic check - in real pentesting, check multiple response points
                    if payload in response.text and field == "message":
                        details = f"Potential XSS vulnerability found in field '{field}' with payload: {payload[:50]}..."
                        self.add_test_result(f"XSS Test - {field}", False, "high", details, "Cross-Site Scripting")
                        break  # Stop testing other payloads for this field if vulnerability found
                    else:
                        # If payload is properly sanitized, the test passes
                        if payload not in response.text:
                            self.add_test_result(f"XSS Test - {field} (with payload: {payload[:20]}...)", True, "low")
                
                except Exception as e:
                    self.add_test_result(f"XSS Test - {field}", False, "medium", str(e), "HTTP Error")
                    break  # Continue to next field

    def test_sql_injection(self):
        """Test for SQL Injection vulnerabilities"""
        print("\nüîç Testing for SQL Injection Vulnerabilities...")
        
        # SQL injection payloads
        sqli_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "' UNION SELECT NULL, NULL, NULL --",
            "'; DROP TABLE users; --",
            "' AND 1=1 --",
            "' AND 1=2 --",
            "admin'--",
            "admin' OR '1'='1",
        ]
        
        # Test contact form fields for SQL injection
        contact_form_fields = ["name", "email", "company"]
        
        for field in contact_form_fields:
            for payload in sqli_payloads:
                test_data = {
                    "name": "Test User",
                    "email": "test@example.com",
                    "phone": "+49 123 456789",
                    "company": "Test Company",
                    "message": "Test message"
                }
                
                # Inject the payload into the current field
                test_data[field] = payload
                
                try:
                    # Submit form and check response
                    response = self.session.post(self.base_url, data=test_data, timeout=self.timeout)
                    
                    # Look for common SQL error messages in response
                    sql_errors = [
                        "sql syntax",
                        "mysql", "mssql", "oracle", "postgresql",
                        "syntax error", "error in your sql",
                        "unrecognized token", "sqlite"
                    ]
                    
                    response_text = response.text.lower()
                    has_sql_error = any(error in response_text for error in sql_errors)
                    
                    if has_sql_error:
                        details = f"SQL injection vulnerability detected in field '{field}' with payload: {payload[:50]}..."
                        self.add_test_result(f"SQL Injection Test - {field}", False, "critical", details, "SQL Injection")
                        break  # Stop testing other payloads for this field
                    else:
                        self.add_test_result(f"SQL Injection Test - {field} (payload: {payload[:20]}...)", True, "low")
                        
                except Exception as e:
                    self.add_test_result(f"SQL Injection Test - {field}", False, "medium", str(e), "HTTP Error")
                    break  # Continue to next field

    def test_form_validation_bypass(self):
        """Test for form validation bypass"""
        print("\nüîç Testing Form Validation Bypass...")
        
        # Test with empty required fields
        bypass_tests = [
            {"name": "", "email": "test@example.com", "phone": "+49 123", "company": "Test", "message": "Test"},
            {"name": "Test", "email": "", "phone": "+49 123", "company": "Test", "message": "Test"},
            {"name": "Test", "email": "invalid-email", "phone": "+49 123", "company": "Test", "message": "Test"},
            {"name": "Test", "email": "test@example.com", "phone": "+49 123", "company": "", "message": "Test"},
            {"name": "Test", "email": "test@example.com", "phone": "+49 123", "company": "Test", "message": "Hi"},  # Too short
        ]
        
        for i, test_data in enumerate(bypass_tests):
            try:
                response = self.session.post(self.base_url, data=test_data, timeout=self.timeout)
                
                # If the server doesn't validate and accepts the data, that's a vulnerability
                # This is tricky to determine with HTTP requests alone, so we'll test for expected behavior
                if response.status_code in [200, 302, 303]:
                    # Check if response suggests the form was accepted despite validation
                    response_text = response.text.lower()
                    if "success" in response_text or "thank you" in response_text or "contact" not in response_text:
                        details = f"Form validation bypass possible with test case {i+1}: {test_data}"
                        self.add_test_result(f"Form Validation Bypass Test {i+1}", False, "medium", details, "Form Validation Bypass")
                    else:
                        self.add_test_result(f"Form Validation Bypass Test {i+1}", True, "low")
                else:
                    self.add_test_result(f"Form Validation Bypass Test {i+1}", True, "low")
                        
            except Exception as e:
                self.add_test_result(f"Form Validation Bypass Test {i+1}", False, "medium", str(e), "HTTP Error")

    def test_ninox_api_integration(self):
        """Test for Ninox API integration vulnerabilities"""
        print("\nüîç Testing Ninox API Integration...")
        
        # Check environment for Ninox configuration (this would typically be done on the server side)
        # For now, we'll test if there are any exposed API endpoints
        common_ninox_paths = [
            "/api/ninox/",
            "/ninox/",
            "/api/v1/ninox/",
            "/contacts/ninox",
        ]
        
        vulnerable_endpoints_found = False
        
        for path in common_ninox_paths:
            try:
                url = urljoin(self.base_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code not in [404, 403, 405]:
                    details = f"Potentially exposed Ninox API endpoint found: {url} (Status: {response.status_code})"
                    self.add_test_result("Ninox API Endpoint Exposure", False, "high", details, "Exposed API Endpoint")
                    vulnerable_endpoints_found = True
                    break
            except Exception:
                continue
        
        if not vulnerable_endpoints_found:
            self.add_test_result("Ninox API Endpoint Exposure", True, "low")

    def test_csrf_vulnerabilities(self):
        """Test for CSRF vulnerabilities"""
        print("\nüîç Testing for CSRF Vulnerabilities...")
        
        # Check if there's a CSRF token in forms
        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            content = response.text
            
            # Look for CSRF tokens (common names)
            csrf_indicators = [
                "csrf_token",
                "csrf",
                "anticsrf",
                "authenticity_token",
                "xsrf-token",
                "_token"
            ]
            
            has_csrf_protection = any(indicator in content.lower() for indicator in csrf_indicators)
            
            if not has_csrf_protection:
                details = "No CSRF protection tokens found in the form. This could indicate a potential CSRF vulnerability."
                self.add_test_result("CSRF Protection Check", False, "high", details, "Missing CSRF Protection")
            else:
                self.add_test_result("CSRF Protection Check", True, "low", "CSRF protection tokens detected")
                
        except Exception as e:
            self.add_test_result("CSRF Protection Check", False, "medium", str(e), "HTTP Error")

    def test_directory_enumeration(self):
        """Test for directory enumeration vulnerabilities"""
        print("\nüîç Testing for Directory Enumeration...")
        
        # Common sensitive directories/files to check
        sensitive_paths = [
            ".git/",
            ".env",
            "admin/",
            "wp-admin/",
            "wp-login.php",
            "login/",
            "config.php",
            "database.php",
            "backup.sql",
            "dump.sql",
            "phpinfo.php",
            "install.php",
            "maintenance.php",
            ".htaccess",
            "server-status",
            "server-info",
            "debug/",
            "logs/",
            "log/",
            "tmp/",
            "temp/",
            "upload/",
            "uploads/",
            "images/uploads/",
            "documents/",
            "backup/",
            "backups/",
            "db.sql",
            "database.sql",
            "old/",
            "new/",
            "test/",
            "testing/",
            "dev/",
            "development/",
            "staging/",
            "api/",
            "api/v1/",
            "api/v2/",
            "graphql",
            "swagger.json",
            "swagger.yaml",
            "swagger-ui.html",
            "api-docs",
            "docs/",
            "apidoc/",
            "api-explorer/"
        ]
        
        accessible_paths = []
        
        for path in sensitive_paths:
            try:
                url = urljoin(self.base_url, path)
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code not in [404, 403]:
                    accessible_paths.append((path, response.status_code))
                    
            except Exception:
                continue
        
        if accessible_paths:
            details = "Accessible sensitive paths found: " + ", ".join([f"{path}({status})" for path, status in accessible_paths])
            self.add_test_result("Directory Enumeration", False, "medium", details, "Exposed Sensitive Directories")
        else:
            self.add_test_result("Directory Enumeration", True, "low")

    def test_information_disclosure(self):
        """Test for information disclosure"""
        print("\nüîç Testing for Information Disclosure...")
        
        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            
            # Check for common information disclosure patterns
            content = response.text
            
            # Look for version information, stack traces, etc.
            disclosure_indicators = [
                "django/",
                "flask/",
                "python/",
                "reflex/",
                "gunicorn/",
                "nginx/",
                "apache/",
                "debug",
                "stack trace",
                "traceback",
                "file:",
                "line:",
                "error in your sql syntax",
                "mysql",
                "postgresql",
                "sqlite",
                "connection failed",
                "permission denied",
                "internal server error"
            ]
            
            found_disclosures = []
            for indicator in disclosure_indicators:
                if indicator.lower() in content.lower():
                    found_disclosures.append(indicator)
            
            if found_disclosures:
                details = f"Information disclosure found: {', '.join(found_disclosures)}"
                self.add_test_result("Information Disclosure", False, "medium", details, "Information Disclosure")
            else:
                self.add_test_result("Information Disclosure", True, "low")
                
        except Exception as e:
            self.add_test_result("Information Disclosure", False, "medium", str(e), "HTTP Error")

    def run_all_tests(self):
        """Run all pentest modules"""
        print(f"üöÄ Starting Pentest for: {self.base_url}\n")
        print("="*60)
        
        # Run all tests
        self.check_security_headers()
        self.test_xss_vulnerabilities()
        self.test_sql_injection()
        self.test_form_validation_bypass()
        self.test_ninox_api_integration()
        self.test_csrf_vulnerabilities()
        self.test_directory_enumeration()
        self.test_information_disclosure()
        
        # Print summary
        print("\n" + "="*60)
        print("PENTEST SUMMARY")
        print("="*60)
        summary = self.test_results["summary"]
        print(f"Target: {self.test_results['target']}")
        print(f"Total tests: {summary['total_tests']}")
        print(f"Passed: {summary['passed_tests']}")
        print(f"Failed: {summary['failed_tests']}")
        print(f"Critical vulnerabilities: {summary['critical_vulnerabilities']}")
        print(f"High vulnerabilities: {summary['high_vulnerabilities']}")
        print(f"Medium vulnerabilities: {summary['medium_vulnerabilities']}")
        print(f"Low vulnerabilities: {summary['low_vulnerabilities']}")
        
        if summary['vulnerabilities_found']:
            print(f"\nVulnerabilities found:")
            for i, vuln in enumerate(summary['vulnerabilities_found'], 1):
                print(f"  {i}. {vuln['type']} ({vuln['severity'].upper()}) - {vuln['test']}")
                print(f"     Details: {vuln['details'][:100]}...")
        
        print("="*60)

    def save_results(self, filename: str = "pentest_results.json"):
        """Save pentest results to a file"""
        self.test_results["end_time"] = datetime.now().isoformat()
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.test_results, f, indent=2, ensure_ascii=False)
        
        print(f"\nPentest results saved to {filename}")


def main():
    parser = argparse.ArgumentParser(description="Penetration Testing Tool for S√ºdwest-Energie Website")
    parser.add_argument("--url", default="http://localhost:3000", help="Target website URL (default: http://localhost:3000)")
    parser.add_argument("--timeout", type=int, default=10, help="Request timeout in seconds (default: 10)")
    parser.add_argument("--output", default="pentest_results.json", help="Output file for results (default: pentest_results.json)")
    
    args = parser.parse_args()
    
    # Check if server is accessible
    print(f"Checking if {args.url} is accessible...")
    try:
        response = requests.get(args.url, timeout=args.timeout)
        if response.status_code not in [200, 404, 403]:  # Allow common status codes
            print(f"‚ùå Server at {args.url} is not responding appropriately (Status: {response.status_code})")
            return
    except requests.ConnectionError:
        print(f"‚ùå Cannot connect to server at {args.url}")
        print("Make sure the website is running before running the pentest")
        return
    except requests.Timeout:
        print(f"‚ùå Connection to {args.url} timed out")
        return
    except Exception as e:
        print(f"‚ùå Error connecting to {args.url}: {e}")
        return
    
    # Initialize and run pentester
    pentester = SudwestEnergiePentester(base_url=args.url, timeout=args.timeout)
    pentester.run_all_tests()
    pentester.save_results(args.output)
    
    print(f"\n‚úÖ Pentest completed! Results saved to {args.output}")


if __name__ == "__main__":
    main()